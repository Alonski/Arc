# *contract* QuorumVote
[object Object]
## Events
### *event* LogNewProposal
*Parameters:*
1. **_proposalId** *of type bytes32*
2. **_numOfChoices** *of type uint256*
3. **_proposer** *of type address*
4. **_paramsHash** *of type bytes32*

### *event* LogCancelProposal
*Parameters:*
1. **_proposalId** *of type bytes32*

### *event* LogExecuteProposal
*Parameters:*
1. **_proposalId** *of type bytes32*
2. **_decision** *of type uint256*

### *event* LogVoteProposal
*Parameters:*
1. **_proposalId** *of type bytes32*
2. **_voter** *of type address*
3. **_vote** *of type uint256*
4. **_reputation** *of type uint256*
5. **_isOwnerVote** *of type bool*

### *event* LogCancelVoting
*Parameters:*
1. **_proposalId** *of type bytes32*
2. **_voter** *of type address*

## Functions
### *function* parameters

**constant**
**payable**
**view**




*Inputs:*
1. **unnamed** *of type bytes32* - 

*Returns:*
1. **address**
2. **uint256**
3. **bool**

### *function* getParametersHash

**constant**
**payable**
**pure**


hashParameters returns a hash of the given parameters

*Inputs:*
1. **_reputationSystem** *of type address* - 
2. **_precReq** *of type uint256* - 
3. **_allowOwner** *of type bool* - 

*Returns:*
*Nothing*

### *function* voteInfo

**constant**
**payable**
**view**


voteInfo returns the vote and the amount of reputation of the user committed to this proposal

*Inputs:*
1. **_proposalId** *of type bytes32* - the ID of the proposal
2. **_voter** *of type address* - the address of the voter

*Returns:*
uint vote - the voters vote       uint reputation - amount of reputation committed by _voter to _proposalId

### *function* proposals

**constant**
**payable**
**view**




*Inputs:*
1. **unnamed** *of type bytes32* - 

*Returns:*
1. **address**
2. **address**
3. **uint256**
4. **address**
5. **bytes32**
6. **uint256**
7. **bool**

### *function* ownerVote

**nonpayable**


voting function with owner functionality (can vote on behalf of someone else)

*Inputs:*
1. **_proposalId** *of type bytes32* - id of the proposal
2. **_vote** *of type uint256* - a value between 0 to and the proposal number of choices.
3. **_voter** *of type address* - will be voted with that voter's address

*Returns:*
bool true - the proposal has been executed             false - otherwise.

### *function* cancelProposal

**nonpayable**


Cancel a proposal, only the owner can call this function and only if allowOwner flag is true.

*Inputs:*
1. **_proposalId** *of type bytes32* - the proposal ID

*Returns:*
*Nothing*

### *function* propose

**nonpayable**


register a new proposal with the given parameters. Every proposal has a unique ID which is being generated by calculating keccak256 of a incremented counter.

*Inputs:*
1. **_numOfChoices** *of type uint256* - undefined
2. **_paramsHash** *of type bytes32* - defined the parameters of the voting machine used for this proposal
3. **_avatar** *of type address* - an address to be sent as the payload to the _executable contract.
4. **_executable** *of type address* - This contract will be executed when vote is over. TODO: Maybe we need to check the 0 < precReq <= 100 ??

*Returns:*
*Nothing*

### *function* votesStatus

**constant**
**payable**
**view**


votesStatus returns the number of yes, no, and abstain and if the proposal is ended of a given proposal id

*Inputs:*
1. **_proposalId** *of type bytes32* - the ID of the proposal

*Returns:*
votes array of votes for each choice

### *function* cancelVote

**nonpayable**


Cancel the vote of the msg.sender: subtract the reputation amount from the votes and delete the voter from the proposal struct

*Inputs:*
1. **_proposalId** *of type bytes32* - id of the proposal

*Returns:*
*Nothing*

### *function* vote

**nonpayable**


voting function

*Inputs:*
1. **_proposalId** *of type bytes32* - id of the proposal
2. **_vote** *of type uint256* - a value between 0 to and the proposal number of choices.

*Returns:*
bool true - the proposal has been executed             false - otherwise.

### *function* getNumberOfChoices

**constant**
**payable**
**view**


getNumberOfChoices returns the number of choices possible in this proposal

*Inputs:*
1. **_proposalId** *of type bytes32* - the ID of the proposal

*Returns:*
uint that contains number of choices

### *function* voteWithSpecifiedAmounts

**nonpayable**




*Inputs:*
1. **_proposalId** *of type bytes32* - 
2. **_vote** *of type uint256* - 
3. **_rep** *of type uint256* - 
4. **unnamed** *of type uint256* - 

*Returns:*
1. **bool**

### *function* isVotable

**constant**
**payable**
**view**


isVotable check if the proposal is votable

*Inputs:*
1. **_proposalId** *of type bytes32* - the ID of the proposal

*Returns:*
bool true or false

### *function* execute

**nonpayable**


check if the proposal has been decided, and if so, execute the proposal

*Inputs:*
1. **_proposalId** *of type bytes32* - the id of the proposal

*Returns:*
*Nothing*

### *function* setParameters

**nonpayable**


hash the parameters, save them if necessary, and return the hash value

*Inputs:*
1. **_reputationSystem** *of type address* - 
2. **_precReq** *of type uint256* - 
3. **_allowOwner** *of type bool* - 

*Returns:*
*Nothing*

